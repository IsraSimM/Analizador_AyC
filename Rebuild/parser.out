Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    DOT

Grammar

Rule 0     S' -> program
Rule 1     program -> preprocesor_directives_list function
Rule 2     program -> function
Rule 3     preprocesor_directives_list -> preprocesor_directive preprocesor_directives_list
Rule 4     preprocesor_directives_list -> preprocesor_directive
Rule 5     preprocesor_directive -> INCLUDE HEADER
Rule 6     function -> INT MAIN LPAREN RPAREN LBRACE statement_list RBRACE
Rule 7     statement_list -> statement statement_list
Rule 8     statement_list -> statement
Rule 9     statement -> declaration
Rule 10    statement -> assignment
Rule 11    statement -> for_loop
Rule 12    statement -> if_statement
Rule 13    statement -> function_call
Rule 14    statement -> return_statement
Rule 15    identifier_list -> IDENTIFIER
Rule 16    identifier_list -> IDENTIFIER COMMA identifier_list
Rule 17    declaration -> type_specifier IDENTIFIER EQUAL expression SEMICOLON
Rule 18    declaration -> type_specifier identifier_list SEMICOLON
Rule 19    declaration -> type_specifier identifier_list EQUAL expression SEMICOLON
Rule 20    declaration -> type_specifier identifier_list LBRAKET NUMBER RBRAKET SEMICOLON
Rule 21    type_specifier -> INT
Rule 22    type_specifier -> FLOAT
Rule 23    type_specifier -> CHAR
Rule 24    compound_assignment -> PLUS EQUAL
Rule 25    compound_assignment -> MINUS EQUAL
Rule 26    compound_assignment -> TIMES EQUAL
Rule 27    compound_assignment -> DIVIDE EQUAL
Rule 28    assignment -> IDENTIFIER EQUAL expression SEMICOLON
Rule 29    assignment -> IDENTIFIER compound_assignment expression SEMICOLON
Rule 30    assignment -> IDENTIFIER LBRAKET expression RBRAKET compound_assignment expression SEMICOLON
Rule 31    assignment -> IDENTIFIER LBRAKET expression RBRAKET EQUAL expression SEMICOLON
Rule 32    expression -> expression PLUS expression
Rule 33    expression -> expression MINUS expression
Rule 34    expression -> expression TIMES expression
Rule 35    expression -> expression DIVIDE expression
Rule 36    expression -> LPAREN expression RPAREN
Rule 37    expression -> NUMBER
Rule 38    expression -> CHAR_LITERAL
Rule 39    expression -> CHAR
Rule 40    expression -> IDENTIFIER
Rule 41    expression -> IDENTIFIER LBRAKET expression RBRAKET
Rule 42    expression_list -> expression
Rule 43    expression_list -> expression COMMA expression_list
Rule 44    unitarymodifiers -> IDENTIFIER PLUS PLUS
Rule 45    unitarymodifiers -> IDENTIFIER MINUS MINUS
Rule 46    for_loop -> FOR LPAREN assignment condition SEMICOLON unitarymodifiers RPAREN LBRACE statement_list RBRACE
Rule 47    condition -> expression COMPARER expression
Rule 48    if_statement -> IF LPAREN condition RPAREN LBRACE statement_list RBRACE
Rule 49    if_statement -> IF LPAREN condition RPAREN LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE
Rule 50    function_call -> PRINTF LPAREN STRING COMMA IDENTIFIER RPAREN SEMICOLON
Rule 51    function_call -> PRINTF LPAREN STRING RPAREN SEMICOLON
Rule 52    function_call -> PRINTF LPAREN STRING COMMA expression_list RPAREN SEMICOLON
Rule 53    function_call -> SCANF LPAREN STRING COMMA AMPERSAND IDENTIFIER RPAREN SEMICOLON
Rule 54    return_statement -> RETURN SEMICOLON
Rule 55    return_statement -> RETURN expression SEMICOLON

Terminals, with rules where they appear

AMPERSAND            : 53
CHAR                 : 23 39
CHAR_LITERAL         : 38
COMMA                : 16 43 50 52 53
COMPARER             : 47
DIVIDE               : 27 35
DOT                  : 
ELSE                 : 49
EQUAL                : 17 19 24 25 26 27 28 31
FLOAT                : 22
FOR                  : 46
HEADER               : 5
IDENTIFIER           : 15 16 17 28 29 30 31 40 41 44 45 50 53
IF                   : 48 49
INCLUDE              : 5
INT                  : 6 21
LBRACE               : 6 46 48 49 49
LBRAKET              : 20 30 31 41
LPAREN               : 6 36 46 48 49 50 51 52 53
MAIN                 : 6
MINUS                : 25 33 45 45
NUMBER               : 20 37
PLUS                 : 24 32 44 44
PRINTF               : 50 51 52
RBRACE               : 6 46 48 49 49
RBRAKET              : 20 30 31 41
RETURN               : 54 55
RPAREN               : 6 36 46 48 49 50 51 52 53
SCANF                : 53
SEMICOLON            : 17 18 19 20 28 29 30 31 46 50 51 52 53 54 55
STRING               : 50 51 52 53
TIMES                : 26 34
error                : 

Nonterminals, with rules where they appear

assignment           : 10 46
compound_assignment  : 29 30
condition            : 46 48 49
declaration          : 9
expression           : 17 19 28 29 30 30 31 31 32 32 33 33 34 34 35 35 36 41 42 43 47 47 55
expression_list      : 43 52
for_loop             : 11
function             : 1 2
function_call        : 13
identifier_list      : 16 18 19 20
if_statement         : 12
preprocesor_directive : 3 4
preprocesor_directives_list : 1 3
program              : 0
return_statement     : 14
statement            : 7 8
statement_list       : 6 7 46 48 49 49
type_specifier       : 17 18 19 20
unitarymodifiers     : 46

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . preprocesor_directives_list function
    (2) program -> . function
    (3) preprocesor_directives_list -> . preprocesor_directive preprocesor_directives_list
    (4) preprocesor_directives_list -> . preprocesor_directive
    (6) function -> . INT MAIN LPAREN RPAREN LBRACE statement_list RBRACE
    (5) preprocesor_directive -> . INCLUDE HEADER

    INT             shift and go to state 5
    INCLUDE         shift and go to state 6

    program                        shift and go to state 1
    preprocesor_directives_list    shift and go to state 2
    function                       shift and go to state 3
    preprocesor_directive          shift and go to state 4

state 1

    (0) S' -> program .



state 2

    (1) program -> preprocesor_directives_list . function
    (6) function -> . INT MAIN LPAREN RPAREN LBRACE statement_list RBRACE

    INT             shift and go to state 5

    function                       shift and go to state 7

state 3

    (2) program -> function .

    $end            reduce using rule 2 (program -> function .)


state 4

    (3) preprocesor_directives_list -> preprocesor_directive . preprocesor_directives_list
    (4) preprocesor_directives_list -> preprocesor_directive .
    (3) preprocesor_directives_list -> . preprocesor_directive preprocesor_directives_list
    (4) preprocesor_directives_list -> . preprocesor_directive
    (5) preprocesor_directive -> . INCLUDE HEADER

    INT             reduce using rule 4 (preprocesor_directives_list -> preprocesor_directive .)
    INCLUDE         shift and go to state 6

    preprocesor_directive          shift and go to state 4
    preprocesor_directives_list    shift and go to state 8

state 5

    (6) function -> INT . MAIN LPAREN RPAREN LBRACE statement_list RBRACE

    MAIN            shift and go to state 9


state 6

    (5) preprocesor_directive -> INCLUDE . HEADER

    HEADER          shift and go to state 10


state 7

    (1) program -> preprocesor_directives_list function .

    $end            reduce using rule 1 (program -> preprocesor_directives_list function .)


state 8

    (3) preprocesor_directives_list -> preprocesor_directive preprocesor_directives_list .

    INT             reduce using rule 3 (preprocesor_directives_list -> preprocesor_directive preprocesor_directives_list .)


state 9

    (6) function -> INT MAIN . LPAREN RPAREN LBRACE statement_list RBRACE

    LPAREN          shift and go to state 11


state 10

    (5) preprocesor_directive -> INCLUDE HEADER .

    INCLUDE         reduce using rule 5 (preprocesor_directive -> INCLUDE HEADER .)
    INT             reduce using rule 5 (preprocesor_directive -> INCLUDE HEADER .)


state 11

    (6) function -> INT MAIN LPAREN . RPAREN LBRACE statement_list RBRACE

    RPAREN          shift and go to state 12


state 12

    (6) function -> INT MAIN LPAREN RPAREN . LBRACE statement_list RBRACE

    LBRACE          shift and go to state 13


state 13

    (6) function -> INT MAIN LPAREN RPAREN LBRACE . statement_list RBRACE
    (7) statement_list -> . statement statement_list
    (8) statement_list -> . statement
    (9) statement -> . declaration
    (10) statement -> . assignment
    (11) statement -> . for_loop
    (12) statement -> . if_statement
    (13) statement -> . function_call
    (14) statement -> . return_statement
    (17) declaration -> . type_specifier IDENTIFIER EQUAL expression SEMICOLON
    (18) declaration -> . type_specifier identifier_list SEMICOLON
    (19) declaration -> . type_specifier identifier_list EQUAL expression SEMICOLON
    (20) declaration -> . type_specifier identifier_list LBRAKET NUMBER RBRAKET SEMICOLON
    (28) assignment -> . IDENTIFIER EQUAL expression SEMICOLON
    (29) assignment -> . IDENTIFIER compound_assignment expression SEMICOLON
    (30) assignment -> . IDENTIFIER LBRAKET expression RBRAKET compound_assignment expression SEMICOLON
    (31) assignment -> . IDENTIFIER LBRAKET expression RBRAKET EQUAL expression SEMICOLON
    (46) for_loop -> . FOR LPAREN assignment condition SEMICOLON unitarymodifiers RPAREN LBRACE statement_list RBRACE
    (48) if_statement -> . IF LPAREN condition RPAREN LBRACE statement_list RBRACE
    (49) if_statement -> . IF LPAREN condition RPAREN LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE
    (50) function_call -> . PRINTF LPAREN STRING COMMA IDENTIFIER RPAREN SEMICOLON
    (51) function_call -> . PRINTF LPAREN STRING RPAREN SEMICOLON
    (52) function_call -> . PRINTF LPAREN STRING COMMA expression_list RPAREN SEMICOLON
    (53) function_call -> . SCANF LPAREN STRING COMMA AMPERSAND IDENTIFIER RPAREN SEMICOLON
    (54) return_statement -> . RETURN SEMICOLON
    (55) return_statement -> . RETURN expression SEMICOLON
    (21) type_specifier -> . INT
    (22) type_specifier -> . FLOAT
    (23) type_specifier -> . CHAR

    IDENTIFIER      shift and go to state 24
    FOR             shift and go to state 25
    IF              shift and go to state 26
    PRINTF          shift and go to state 27
    SCANF           shift and go to state 28
    RETURN          shift and go to state 29
    INT             shift and go to state 14
    FLOAT           shift and go to state 30
    CHAR            shift and go to state 31

    statement_list                 shift and go to state 15
    statement                      shift and go to state 16
    declaration                    shift and go to state 17
    assignment                     shift and go to state 18
    for_loop                       shift and go to state 19
    if_statement                   shift and go to state 20
    function_call                  shift and go to state 21
    return_statement               shift and go to state 22
    type_specifier                 shift and go to state 23

state 14

    (21) type_specifier -> INT .

    IDENTIFIER      reduce using rule 21 (type_specifier -> INT .)


state 15

    (6) function -> INT MAIN LPAREN RPAREN LBRACE statement_list . RBRACE

    RBRACE          shift and go to state 32


state 16

    (7) statement_list -> statement . statement_list
    (8) statement_list -> statement .
    (7) statement_list -> . statement statement_list
    (8) statement_list -> . statement
    (9) statement -> . declaration
    (10) statement -> . assignment
    (11) statement -> . for_loop
    (12) statement -> . if_statement
    (13) statement -> . function_call
    (14) statement -> . return_statement
    (17) declaration -> . type_specifier IDENTIFIER EQUAL expression SEMICOLON
    (18) declaration -> . type_specifier identifier_list SEMICOLON
    (19) declaration -> . type_specifier identifier_list EQUAL expression SEMICOLON
    (20) declaration -> . type_specifier identifier_list LBRAKET NUMBER RBRAKET SEMICOLON
    (28) assignment -> . IDENTIFIER EQUAL expression SEMICOLON
    (29) assignment -> . IDENTIFIER compound_assignment expression SEMICOLON
    (30) assignment -> . IDENTIFIER LBRAKET expression RBRAKET compound_assignment expression SEMICOLON
    (31) assignment -> . IDENTIFIER LBRAKET expression RBRAKET EQUAL expression SEMICOLON
    (46) for_loop -> . FOR LPAREN assignment condition SEMICOLON unitarymodifiers RPAREN LBRACE statement_list RBRACE
    (48) if_statement -> . IF LPAREN condition RPAREN LBRACE statement_list RBRACE
    (49) if_statement -> . IF LPAREN condition RPAREN LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE
    (50) function_call -> . PRINTF LPAREN STRING COMMA IDENTIFIER RPAREN SEMICOLON
    (51) function_call -> . PRINTF LPAREN STRING RPAREN SEMICOLON
    (52) function_call -> . PRINTF LPAREN STRING COMMA expression_list RPAREN SEMICOLON
    (53) function_call -> . SCANF LPAREN STRING COMMA AMPERSAND IDENTIFIER RPAREN SEMICOLON
    (54) return_statement -> . RETURN SEMICOLON
    (55) return_statement -> . RETURN expression SEMICOLON
    (21) type_specifier -> . INT
    (22) type_specifier -> . FLOAT
    (23) type_specifier -> . CHAR

    RBRACE          reduce using rule 8 (statement_list -> statement .)
    IDENTIFIER      shift and go to state 24
    FOR             shift and go to state 25
    IF              shift and go to state 26
    PRINTF          shift and go to state 27
    SCANF           shift and go to state 28
    RETURN          shift and go to state 29
    INT             shift and go to state 14
    FLOAT           shift and go to state 30
    CHAR            shift and go to state 31

    statement                      shift and go to state 16
    statement_list                 shift and go to state 33
    declaration                    shift and go to state 17
    assignment                     shift and go to state 18
    for_loop                       shift and go to state 19
    if_statement                   shift and go to state 20
    function_call                  shift and go to state 21
    return_statement               shift and go to state 22
    type_specifier                 shift and go to state 23

state 17

    (9) statement -> declaration .

    IDENTIFIER      reduce using rule 9 (statement -> declaration .)
    FOR             reduce using rule 9 (statement -> declaration .)
    IF              reduce using rule 9 (statement -> declaration .)
    PRINTF          reduce using rule 9 (statement -> declaration .)
    SCANF           reduce using rule 9 (statement -> declaration .)
    RETURN          reduce using rule 9 (statement -> declaration .)
    INT             reduce using rule 9 (statement -> declaration .)
    FLOAT           reduce using rule 9 (statement -> declaration .)
    CHAR            reduce using rule 9 (statement -> declaration .)
    RBRACE          reduce using rule 9 (statement -> declaration .)


state 18

    (10) statement -> assignment .

    IDENTIFIER      reduce using rule 10 (statement -> assignment .)
    FOR             reduce using rule 10 (statement -> assignment .)
    IF              reduce using rule 10 (statement -> assignment .)
    PRINTF          reduce using rule 10 (statement -> assignment .)
    SCANF           reduce using rule 10 (statement -> assignment .)
    RETURN          reduce using rule 10 (statement -> assignment .)
    INT             reduce using rule 10 (statement -> assignment .)
    FLOAT           reduce using rule 10 (statement -> assignment .)
    CHAR            reduce using rule 10 (statement -> assignment .)
    RBRACE          reduce using rule 10 (statement -> assignment .)


state 19

    (11) statement -> for_loop .

    IDENTIFIER      reduce using rule 11 (statement -> for_loop .)
    FOR             reduce using rule 11 (statement -> for_loop .)
    IF              reduce using rule 11 (statement -> for_loop .)
    PRINTF          reduce using rule 11 (statement -> for_loop .)
    SCANF           reduce using rule 11 (statement -> for_loop .)
    RETURN          reduce using rule 11 (statement -> for_loop .)
    INT             reduce using rule 11 (statement -> for_loop .)
    FLOAT           reduce using rule 11 (statement -> for_loop .)
    CHAR            reduce using rule 11 (statement -> for_loop .)
    RBRACE          reduce using rule 11 (statement -> for_loop .)


state 20

    (12) statement -> if_statement .

    IDENTIFIER      reduce using rule 12 (statement -> if_statement .)
    FOR             reduce using rule 12 (statement -> if_statement .)
    IF              reduce using rule 12 (statement -> if_statement .)
    PRINTF          reduce using rule 12 (statement -> if_statement .)
    SCANF           reduce using rule 12 (statement -> if_statement .)
    RETURN          reduce using rule 12 (statement -> if_statement .)
    INT             reduce using rule 12 (statement -> if_statement .)
    FLOAT           reduce using rule 12 (statement -> if_statement .)
    CHAR            reduce using rule 12 (statement -> if_statement .)
    RBRACE          reduce using rule 12 (statement -> if_statement .)


state 21

    (13) statement -> function_call .

    IDENTIFIER      reduce using rule 13 (statement -> function_call .)
    FOR             reduce using rule 13 (statement -> function_call .)
    IF              reduce using rule 13 (statement -> function_call .)
    PRINTF          reduce using rule 13 (statement -> function_call .)
    SCANF           reduce using rule 13 (statement -> function_call .)
    RETURN          reduce using rule 13 (statement -> function_call .)
    INT             reduce using rule 13 (statement -> function_call .)
    FLOAT           reduce using rule 13 (statement -> function_call .)
    CHAR            reduce using rule 13 (statement -> function_call .)
    RBRACE          reduce using rule 13 (statement -> function_call .)


state 22

    (14) statement -> return_statement .

    IDENTIFIER      reduce using rule 14 (statement -> return_statement .)
    FOR             reduce using rule 14 (statement -> return_statement .)
    IF              reduce using rule 14 (statement -> return_statement .)
    PRINTF          reduce using rule 14 (statement -> return_statement .)
    SCANF           reduce using rule 14 (statement -> return_statement .)
    RETURN          reduce using rule 14 (statement -> return_statement .)
    INT             reduce using rule 14 (statement -> return_statement .)
    FLOAT           reduce using rule 14 (statement -> return_statement .)
    CHAR            reduce using rule 14 (statement -> return_statement .)
    RBRACE          reduce using rule 14 (statement -> return_statement .)


state 23

    (17) declaration -> type_specifier . IDENTIFIER EQUAL expression SEMICOLON
    (18) declaration -> type_specifier . identifier_list SEMICOLON
    (19) declaration -> type_specifier . identifier_list EQUAL expression SEMICOLON
    (20) declaration -> type_specifier . identifier_list LBRAKET NUMBER RBRAKET SEMICOLON
    (15) identifier_list -> . IDENTIFIER
    (16) identifier_list -> . IDENTIFIER COMMA identifier_list

    IDENTIFIER      shift and go to state 34

    identifier_list                shift and go to state 35

state 24

    (28) assignment -> IDENTIFIER . EQUAL expression SEMICOLON
    (29) assignment -> IDENTIFIER . compound_assignment expression SEMICOLON
    (30) assignment -> IDENTIFIER . LBRAKET expression RBRAKET compound_assignment expression SEMICOLON
    (31) assignment -> IDENTIFIER . LBRAKET expression RBRAKET EQUAL expression SEMICOLON
    (24) compound_assignment -> . PLUS EQUAL
    (25) compound_assignment -> . MINUS EQUAL
    (26) compound_assignment -> . TIMES EQUAL
    (27) compound_assignment -> . DIVIDE EQUAL

    EQUAL           shift and go to state 36
    LBRAKET         shift and go to state 38
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    TIMES           shift and go to state 41
    DIVIDE          shift and go to state 42

    compound_assignment            shift and go to state 37

state 25

    (46) for_loop -> FOR . LPAREN assignment condition SEMICOLON unitarymodifiers RPAREN LBRACE statement_list RBRACE

    LPAREN          shift and go to state 43


state 26

    (48) if_statement -> IF . LPAREN condition RPAREN LBRACE statement_list RBRACE
    (49) if_statement -> IF . LPAREN condition RPAREN LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE

    LPAREN          shift and go to state 44


state 27

    (50) function_call -> PRINTF . LPAREN STRING COMMA IDENTIFIER RPAREN SEMICOLON
    (51) function_call -> PRINTF . LPAREN STRING RPAREN SEMICOLON
    (52) function_call -> PRINTF . LPAREN STRING COMMA expression_list RPAREN SEMICOLON

    LPAREN          shift and go to state 45


state 28

    (53) function_call -> SCANF . LPAREN STRING COMMA AMPERSAND IDENTIFIER RPAREN SEMICOLON

    LPAREN          shift and go to state 46


state 29

    (54) return_statement -> RETURN . SEMICOLON
    (55) return_statement -> RETURN . expression SEMICOLON
    (32) expression -> . expression PLUS expression
    (33) expression -> . expression MINUS expression
    (34) expression -> . expression TIMES expression
    (35) expression -> . expression DIVIDE expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . NUMBER
    (38) expression -> . CHAR_LITERAL
    (39) expression -> . CHAR
    (40) expression -> . IDENTIFIER
    (41) expression -> . IDENTIFIER LBRAKET expression RBRAKET

    SEMICOLON       shift and go to state 47
    LPAREN          shift and go to state 49
    NUMBER          shift and go to state 50
    CHAR_LITERAL    shift and go to state 51
    CHAR            shift and go to state 52
    IDENTIFIER      shift and go to state 53

    expression                     shift and go to state 48

state 30

    (22) type_specifier -> FLOAT .

    IDENTIFIER      reduce using rule 22 (type_specifier -> FLOAT .)


state 31

    (23) type_specifier -> CHAR .

    IDENTIFIER      reduce using rule 23 (type_specifier -> CHAR .)


state 32

    (6) function -> INT MAIN LPAREN RPAREN LBRACE statement_list RBRACE .

    $end            reduce using rule 6 (function -> INT MAIN LPAREN RPAREN LBRACE statement_list RBRACE .)


state 33

    (7) statement_list -> statement statement_list .

    RBRACE          reduce using rule 7 (statement_list -> statement statement_list .)


state 34

    (17) declaration -> type_specifier IDENTIFIER . EQUAL expression SEMICOLON
    (15) identifier_list -> IDENTIFIER .
    (16) identifier_list -> IDENTIFIER . COMMA identifier_list

  ! shift/reduce conflict for EQUAL resolved as shift
    EQUAL           shift and go to state 54
    SEMICOLON       reduce using rule 15 (identifier_list -> IDENTIFIER .)
    LBRAKET         reduce using rule 15 (identifier_list -> IDENTIFIER .)
    COMMA           shift and go to state 55

  ! EQUAL           [ reduce using rule 15 (identifier_list -> IDENTIFIER .) ]


state 35

    (18) declaration -> type_specifier identifier_list . SEMICOLON
    (19) declaration -> type_specifier identifier_list . EQUAL expression SEMICOLON
    (20) declaration -> type_specifier identifier_list . LBRAKET NUMBER RBRAKET SEMICOLON

    SEMICOLON       shift and go to state 56
    EQUAL           shift and go to state 57
    LBRAKET         shift and go to state 58


state 36

    (28) assignment -> IDENTIFIER EQUAL . expression SEMICOLON
    (32) expression -> . expression PLUS expression
    (33) expression -> . expression MINUS expression
    (34) expression -> . expression TIMES expression
    (35) expression -> . expression DIVIDE expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . NUMBER
    (38) expression -> . CHAR_LITERAL
    (39) expression -> . CHAR
    (40) expression -> . IDENTIFIER
    (41) expression -> . IDENTIFIER LBRAKET expression RBRAKET

    LPAREN          shift and go to state 49
    NUMBER          shift and go to state 50
    CHAR_LITERAL    shift and go to state 51
    CHAR            shift and go to state 52
    IDENTIFIER      shift and go to state 53

    expression                     shift and go to state 59

state 37

    (29) assignment -> IDENTIFIER compound_assignment . expression SEMICOLON
    (32) expression -> . expression PLUS expression
    (33) expression -> . expression MINUS expression
    (34) expression -> . expression TIMES expression
    (35) expression -> . expression DIVIDE expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . NUMBER
    (38) expression -> . CHAR_LITERAL
    (39) expression -> . CHAR
    (40) expression -> . IDENTIFIER
    (41) expression -> . IDENTIFIER LBRAKET expression RBRAKET

    LPAREN          shift and go to state 49
    NUMBER          shift and go to state 50
    CHAR_LITERAL    shift and go to state 51
    CHAR            shift and go to state 52
    IDENTIFIER      shift and go to state 53

    expression                     shift and go to state 60

state 38

    (30) assignment -> IDENTIFIER LBRAKET . expression RBRAKET compound_assignment expression SEMICOLON
    (31) assignment -> IDENTIFIER LBRAKET . expression RBRAKET EQUAL expression SEMICOLON
    (32) expression -> . expression PLUS expression
    (33) expression -> . expression MINUS expression
    (34) expression -> . expression TIMES expression
    (35) expression -> . expression DIVIDE expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . NUMBER
    (38) expression -> . CHAR_LITERAL
    (39) expression -> . CHAR
    (40) expression -> . IDENTIFIER
    (41) expression -> . IDENTIFIER LBRAKET expression RBRAKET

    LPAREN          shift and go to state 49
    NUMBER          shift and go to state 50
    CHAR_LITERAL    shift and go to state 51
    CHAR            shift and go to state 52
    IDENTIFIER      shift and go to state 53

    expression                     shift and go to state 61

state 39

    (24) compound_assignment -> PLUS . EQUAL

    EQUAL           shift and go to state 62


state 40

    (25) compound_assignment -> MINUS . EQUAL

    EQUAL           shift and go to state 63


state 41

    (26) compound_assignment -> TIMES . EQUAL

    EQUAL           shift and go to state 64


state 42

    (27) compound_assignment -> DIVIDE . EQUAL

    EQUAL           shift and go to state 65


state 43

    (46) for_loop -> FOR LPAREN . assignment condition SEMICOLON unitarymodifiers RPAREN LBRACE statement_list RBRACE
    (28) assignment -> . IDENTIFIER EQUAL expression SEMICOLON
    (29) assignment -> . IDENTIFIER compound_assignment expression SEMICOLON
    (30) assignment -> . IDENTIFIER LBRAKET expression RBRAKET compound_assignment expression SEMICOLON
    (31) assignment -> . IDENTIFIER LBRAKET expression RBRAKET EQUAL expression SEMICOLON

    IDENTIFIER      shift and go to state 24

    assignment                     shift and go to state 66

state 44

    (48) if_statement -> IF LPAREN . condition RPAREN LBRACE statement_list RBRACE
    (49) if_statement -> IF LPAREN . condition RPAREN LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE
    (47) condition -> . expression COMPARER expression
    (32) expression -> . expression PLUS expression
    (33) expression -> . expression MINUS expression
    (34) expression -> . expression TIMES expression
    (35) expression -> . expression DIVIDE expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . NUMBER
    (38) expression -> . CHAR_LITERAL
    (39) expression -> . CHAR
    (40) expression -> . IDENTIFIER
    (41) expression -> . IDENTIFIER LBRAKET expression RBRAKET

    LPAREN          shift and go to state 49
    NUMBER          shift and go to state 50
    CHAR_LITERAL    shift and go to state 51
    CHAR            shift and go to state 52
    IDENTIFIER      shift and go to state 53

    condition                      shift and go to state 67
    expression                     shift and go to state 68

state 45

    (50) function_call -> PRINTF LPAREN . STRING COMMA IDENTIFIER RPAREN SEMICOLON
    (51) function_call -> PRINTF LPAREN . STRING RPAREN SEMICOLON
    (52) function_call -> PRINTF LPAREN . STRING COMMA expression_list RPAREN SEMICOLON

    STRING          shift and go to state 69


state 46

    (53) function_call -> SCANF LPAREN . STRING COMMA AMPERSAND IDENTIFIER RPAREN SEMICOLON

    STRING          shift and go to state 70


state 47

    (54) return_statement -> RETURN SEMICOLON .

    IDENTIFIER      reduce using rule 54 (return_statement -> RETURN SEMICOLON .)
    FOR             reduce using rule 54 (return_statement -> RETURN SEMICOLON .)
    IF              reduce using rule 54 (return_statement -> RETURN SEMICOLON .)
    PRINTF          reduce using rule 54 (return_statement -> RETURN SEMICOLON .)
    SCANF           reduce using rule 54 (return_statement -> RETURN SEMICOLON .)
    RETURN          reduce using rule 54 (return_statement -> RETURN SEMICOLON .)
    INT             reduce using rule 54 (return_statement -> RETURN SEMICOLON .)
    FLOAT           reduce using rule 54 (return_statement -> RETURN SEMICOLON .)
    CHAR            reduce using rule 54 (return_statement -> RETURN SEMICOLON .)
    RBRACE          reduce using rule 54 (return_statement -> RETURN SEMICOLON .)


state 48

    (55) return_statement -> RETURN expression . SEMICOLON
    (32) expression -> expression . PLUS expression
    (33) expression -> expression . MINUS expression
    (34) expression -> expression . TIMES expression
    (35) expression -> expression . DIVIDE expression

    SEMICOLON       shift and go to state 71
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 75


state 49

    (36) expression -> LPAREN . expression RPAREN
    (32) expression -> . expression PLUS expression
    (33) expression -> . expression MINUS expression
    (34) expression -> . expression TIMES expression
    (35) expression -> . expression DIVIDE expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . NUMBER
    (38) expression -> . CHAR_LITERAL
    (39) expression -> . CHAR
    (40) expression -> . IDENTIFIER
    (41) expression -> . IDENTIFIER LBRAKET expression RBRAKET

    LPAREN          shift and go to state 49
    NUMBER          shift and go to state 50
    CHAR_LITERAL    shift and go to state 51
    CHAR            shift and go to state 52
    IDENTIFIER      shift and go to state 53

    expression                     shift and go to state 76

state 50

    (37) expression -> NUMBER .

    SEMICOLON       reduce using rule 37 (expression -> NUMBER .)
    PLUS            reduce using rule 37 (expression -> NUMBER .)
    MINUS           reduce using rule 37 (expression -> NUMBER .)
    TIMES           reduce using rule 37 (expression -> NUMBER .)
    DIVIDE          reduce using rule 37 (expression -> NUMBER .)
    RBRAKET         reduce using rule 37 (expression -> NUMBER .)
    COMPARER        reduce using rule 37 (expression -> NUMBER .)
    RPAREN          reduce using rule 37 (expression -> NUMBER .)
    COMMA           reduce using rule 37 (expression -> NUMBER .)


state 51

    (38) expression -> CHAR_LITERAL .

    SEMICOLON       reduce using rule 38 (expression -> CHAR_LITERAL .)
    PLUS            reduce using rule 38 (expression -> CHAR_LITERAL .)
    MINUS           reduce using rule 38 (expression -> CHAR_LITERAL .)
    TIMES           reduce using rule 38 (expression -> CHAR_LITERAL .)
    DIVIDE          reduce using rule 38 (expression -> CHAR_LITERAL .)
    RBRAKET         reduce using rule 38 (expression -> CHAR_LITERAL .)
    COMPARER        reduce using rule 38 (expression -> CHAR_LITERAL .)
    RPAREN          reduce using rule 38 (expression -> CHAR_LITERAL .)
    COMMA           reduce using rule 38 (expression -> CHAR_LITERAL .)


state 52

    (39) expression -> CHAR .

    SEMICOLON       reduce using rule 39 (expression -> CHAR .)
    PLUS            reduce using rule 39 (expression -> CHAR .)
    MINUS           reduce using rule 39 (expression -> CHAR .)
    TIMES           reduce using rule 39 (expression -> CHAR .)
    DIVIDE          reduce using rule 39 (expression -> CHAR .)
    RBRAKET         reduce using rule 39 (expression -> CHAR .)
    COMPARER        reduce using rule 39 (expression -> CHAR .)
    RPAREN          reduce using rule 39 (expression -> CHAR .)
    COMMA           reduce using rule 39 (expression -> CHAR .)


state 53

    (40) expression -> IDENTIFIER .
    (41) expression -> IDENTIFIER . LBRAKET expression RBRAKET

    SEMICOLON       reduce using rule 40 (expression -> IDENTIFIER .)
    PLUS            reduce using rule 40 (expression -> IDENTIFIER .)
    MINUS           reduce using rule 40 (expression -> IDENTIFIER .)
    TIMES           reduce using rule 40 (expression -> IDENTIFIER .)
    DIVIDE          reduce using rule 40 (expression -> IDENTIFIER .)
    RBRAKET         reduce using rule 40 (expression -> IDENTIFIER .)
    COMPARER        reduce using rule 40 (expression -> IDENTIFIER .)
    RPAREN          reduce using rule 40 (expression -> IDENTIFIER .)
    COMMA           reduce using rule 40 (expression -> IDENTIFIER .)
    LBRAKET         shift and go to state 77


state 54

    (17) declaration -> type_specifier IDENTIFIER EQUAL . expression SEMICOLON
    (32) expression -> . expression PLUS expression
    (33) expression -> . expression MINUS expression
    (34) expression -> . expression TIMES expression
    (35) expression -> . expression DIVIDE expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . NUMBER
    (38) expression -> . CHAR_LITERAL
    (39) expression -> . CHAR
    (40) expression -> . IDENTIFIER
    (41) expression -> . IDENTIFIER LBRAKET expression RBRAKET

    LPAREN          shift and go to state 49
    NUMBER          shift and go to state 50
    CHAR_LITERAL    shift and go to state 51
    CHAR            shift and go to state 52
    IDENTIFIER      shift and go to state 53

    expression                     shift and go to state 78

state 55

    (16) identifier_list -> IDENTIFIER COMMA . identifier_list
    (15) identifier_list -> . IDENTIFIER
    (16) identifier_list -> . IDENTIFIER COMMA identifier_list

    IDENTIFIER      shift and go to state 79

    identifier_list                shift and go to state 80

state 56

    (18) declaration -> type_specifier identifier_list SEMICOLON .

    IDENTIFIER      reduce using rule 18 (declaration -> type_specifier identifier_list SEMICOLON .)
    FOR             reduce using rule 18 (declaration -> type_specifier identifier_list SEMICOLON .)
    IF              reduce using rule 18 (declaration -> type_specifier identifier_list SEMICOLON .)
    PRINTF          reduce using rule 18 (declaration -> type_specifier identifier_list SEMICOLON .)
    SCANF           reduce using rule 18 (declaration -> type_specifier identifier_list SEMICOLON .)
    RETURN          reduce using rule 18 (declaration -> type_specifier identifier_list SEMICOLON .)
    INT             reduce using rule 18 (declaration -> type_specifier identifier_list SEMICOLON .)
    FLOAT           reduce using rule 18 (declaration -> type_specifier identifier_list SEMICOLON .)
    CHAR            reduce using rule 18 (declaration -> type_specifier identifier_list SEMICOLON .)
    RBRACE          reduce using rule 18 (declaration -> type_specifier identifier_list SEMICOLON .)


state 57

    (19) declaration -> type_specifier identifier_list EQUAL . expression SEMICOLON
    (32) expression -> . expression PLUS expression
    (33) expression -> . expression MINUS expression
    (34) expression -> . expression TIMES expression
    (35) expression -> . expression DIVIDE expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . NUMBER
    (38) expression -> . CHAR_LITERAL
    (39) expression -> . CHAR
    (40) expression -> . IDENTIFIER
    (41) expression -> . IDENTIFIER LBRAKET expression RBRAKET

    LPAREN          shift and go to state 49
    NUMBER          shift and go to state 50
    CHAR_LITERAL    shift and go to state 51
    CHAR            shift and go to state 52
    IDENTIFIER      shift and go to state 53

    expression                     shift and go to state 81

state 58

    (20) declaration -> type_specifier identifier_list LBRAKET . NUMBER RBRAKET SEMICOLON

    NUMBER          shift and go to state 82


state 59

    (28) assignment -> IDENTIFIER EQUAL expression . SEMICOLON
    (32) expression -> expression . PLUS expression
    (33) expression -> expression . MINUS expression
    (34) expression -> expression . TIMES expression
    (35) expression -> expression . DIVIDE expression

    SEMICOLON       shift and go to state 83
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 75


state 60

    (29) assignment -> IDENTIFIER compound_assignment expression . SEMICOLON
    (32) expression -> expression . PLUS expression
    (33) expression -> expression . MINUS expression
    (34) expression -> expression . TIMES expression
    (35) expression -> expression . DIVIDE expression

    SEMICOLON       shift and go to state 84
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 75


state 61

    (30) assignment -> IDENTIFIER LBRAKET expression . RBRAKET compound_assignment expression SEMICOLON
    (31) assignment -> IDENTIFIER LBRAKET expression . RBRAKET EQUAL expression SEMICOLON
    (32) expression -> expression . PLUS expression
    (33) expression -> expression . MINUS expression
    (34) expression -> expression . TIMES expression
    (35) expression -> expression . DIVIDE expression

    RBRAKET         shift and go to state 85
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 75


state 62

    (24) compound_assignment -> PLUS EQUAL .

    LPAREN          reduce using rule 24 (compound_assignment -> PLUS EQUAL .)
    NUMBER          reduce using rule 24 (compound_assignment -> PLUS EQUAL .)
    CHAR_LITERAL    reduce using rule 24 (compound_assignment -> PLUS EQUAL .)
    CHAR            reduce using rule 24 (compound_assignment -> PLUS EQUAL .)
    IDENTIFIER      reduce using rule 24 (compound_assignment -> PLUS EQUAL .)


state 63

    (25) compound_assignment -> MINUS EQUAL .

    LPAREN          reduce using rule 25 (compound_assignment -> MINUS EQUAL .)
    NUMBER          reduce using rule 25 (compound_assignment -> MINUS EQUAL .)
    CHAR_LITERAL    reduce using rule 25 (compound_assignment -> MINUS EQUAL .)
    CHAR            reduce using rule 25 (compound_assignment -> MINUS EQUAL .)
    IDENTIFIER      reduce using rule 25 (compound_assignment -> MINUS EQUAL .)


state 64

    (26) compound_assignment -> TIMES EQUAL .

    LPAREN          reduce using rule 26 (compound_assignment -> TIMES EQUAL .)
    NUMBER          reduce using rule 26 (compound_assignment -> TIMES EQUAL .)
    CHAR_LITERAL    reduce using rule 26 (compound_assignment -> TIMES EQUAL .)
    CHAR            reduce using rule 26 (compound_assignment -> TIMES EQUAL .)
    IDENTIFIER      reduce using rule 26 (compound_assignment -> TIMES EQUAL .)


state 65

    (27) compound_assignment -> DIVIDE EQUAL .

    LPAREN          reduce using rule 27 (compound_assignment -> DIVIDE EQUAL .)
    NUMBER          reduce using rule 27 (compound_assignment -> DIVIDE EQUAL .)
    CHAR_LITERAL    reduce using rule 27 (compound_assignment -> DIVIDE EQUAL .)
    CHAR            reduce using rule 27 (compound_assignment -> DIVIDE EQUAL .)
    IDENTIFIER      reduce using rule 27 (compound_assignment -> DIVIDE EQUAL .)


state 66

    (46) for_loop -> FOR LPAREN assignment . condition SEMICOLON unitarymodifiers RPAREN LBRACE statement_list RBRACE
    (47) condition -> . expression COMPARER expression
    (32) expression -> . expression PLUS expression
    (33) expression -> . expression MINUS expression
    (34) expression -> . expression TIMES expression
    (35) expression -> . expression DIVIDE expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . NUMBER
    (38) expression -> . CHAR_LITERAL
    (39) expression -> . CHAR
    (40) expression -> . IDENTIFIER
    (41) expression -> . IDENTIFIER LBRAKET expression RBRAKET

    LPAREN          shift and go to state 49
    NUMBER          shift and go to state 50
    CHAR_LITERAL    shift and go to state 51
    CHAR            shift and go to state 52
    IDENTIFIER      shift and go to state 53

    condition                      shift and go to state 86
    expression                     shift and go to state 68

state 67

    (48) if_statement -> IF LPAREN condition . RPAREN LBRACE statement_list RBRACE
    (49) if_statement -> IF LPAREN condition . RPAREN LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE

    RPAREN          shift and go to state 87


state 68

    (47) condition -> expression . COMPARER expression
    (32) expression -> expression . PLUS expression
    (33) expression -> expression . MINUS expression
    (34) expression -> expression . TIMES expression
    (35) expression -> expression . DIVIDE expression

    COMPARER        shift and go to state 88
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 75


state 69

    (50) function_call -> PRINTF LPAREN STRING . COMMA IDENTIFIER RPAREN SEMICOLON
    (51) function_call -> PRINTF LPAREN STRING . RPAREN SEMICOLON
    (52) function_call -> PRINTF LPAREN STRING . COMMA expression_list RPAREN SEMICOLON

    COMMA           shift and go to state 89
    RPAREN          shift and go to state 90


state 70

    (53) function_call -> SCANF LPAREN STRING . COMMA AMPERSAND IDENTIFIER RPAREN SEMICOLON

    COMMA           shift and go to state 91


state 71

    (55) return_statement -> RETURN expression SEMICOLON .

    IDENTIFIER      reduce using rule 55 (return_statement -> RETURN expression SEMICOLON .)
    FOR             reduce using rule 55 (return_statement -> RETURN expression SEMICOLON .)
    IF              reduce using rule 55 (return_statement -> RETURN expression SEMICOLON .)
    PRINTF          reduce using rule 55 (return_statement -> RETURN expression SEMICOLON .)
    SCANF           reduce using rule 55 (return_statement -> RETURN expression SEMICOLON .)
    RETURN          reduce using rule 55 (return_statement -> RETURN expression SEMICOLON .)
    INT             reduce using rule 55 (return_statement -> RETURN expression SEMICOLON .)
    FLOAT           reduce using rule 55 (return_statement -> RETURN expression SEMICOLON .)
    CHAR            reduce using rule 55 (return_statement -> RETURN expression SEMICOLON .)
    RBRACE          reduce using rule 55 (return_statement -> RETURN expression SEMICOLON .)


state 72

    (32) expression -> expression PLUS . expression
    (32) expression -> . expression PLUS expression
    (33) expression -> . expression MINUS expression
    (34) expression -> . expression TIMES expression
    (35) expression -> . expression DIVIDE expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . NUMBER
    (38) expression -> . CHAR_LITERAL
    (39) expression -> . CHAR
    (40) expression -> . IDENTIFIER
    (41) expression -> . IDENTIFIER LBRAKET expression RBRAKET

    LPAREN          shift and go to state 49
    NUMBER          shift and go to state 50
    CHAR_LITERAL    shift and go to state 51
    CHAR            shift and go to state 52
    IDENTIFIER      shift and go to state 53

    expression                     shift and go to state 92

state 73

    (33) expression -> expression MINUS . expression
    (32) expression -> . expression PLUS expression
    (33) expression -> . expression MINUS expression
    (34) expression -> . expression TIMES expression
    (35) expression -> . expression DIVIDE expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . NUMBER
    (38) expression -> . CHAR_LITERAL
    (39) expression -> . CHAR
    (40) expression -> . IDENTIFIER
    (41) expression -> . IDENTIFIER LBRAKET expression RBRAKET

    LPAREN          shift and go to state 49
    NUMBER          shift and go to state 50
    CHAR_LITERAL    shift and go to state 51
    CHAR            shift and go to state 52
    IDENTIFIER      shift and go to state 53

    expression                     shift and go to state 93

state 74

    (34) expression -> expression TIMES . expression
    (32) expression -> . expression PLUS expression
    (33) expression -> . expression MINUS expression
    (34) expression -> . expression TIMES expression
    (35) expression -> . expression DIVIDE expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . NUMBER
    (38) expression -> . CHAR_LITERAL
    (39) expression -> . CHAR
    (40) expression -> . IDENTIFIER
    (41) expression -> . IDENTIFIER LBRAKET expression RBRAKET

    LPAREN          shift and go to state 49
    NUMBER          shift and go to state 50
    CHAR_LITERAL    shift and go to state 51
    CHAR            shift and go to state 52
    IDENTIFIER      shift and go to state 53

    expression                     shift and go to state 94

state 75

    (35) expression -> expression DIVIDE . expression
    (32) expression -> . expression PLUS expression
    (33) expression -> . expression MINUS expression
    (34) expression -> . expression TIMES expression
    (35) expression -> . expression DIVIDE expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . NUMBER
    (38) expression -> . CHAR_LITERAL
    (39) expression -> . CHAR
    (40) expression -> . IDENTIFIER
    (41) expression -> . IDENTIFIER LBRAKET expression RBRAKET

    LPAREN          shift and go to state 49
    NUMBER          shift and go to state 50
    CHAR_LITERAL    shift and go to state 51
    CHAR            shift and go to state 52
    IDENTIFIER      shift and go to state 53

    expression                     shift and go to state 95

state 76

    (36) expression -> LPAREN expression . RPAREN
    (32) expression -> expression . PLUS expression
    (33) expression -> expression . MINUS expression
    (34) expression -> expression . TIMES expression
    (35) expression -> expression . DIVIDE expression

    RPAREN          shift and go to state 96
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 75


state 77

    (41) expression -> IDENTIFIER LBRAKET . expression RBRAKET
    (32) expression -> . expression PLUS expression
    (33) expression -> . expression MINUS expression
    (34) expression -> . expression TIMES expression
    (35) expression -> . expression DIVIDE expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . NUMBER
    (38) expression -> . CHAR_LITERAL
    (39) expression -> . CHAR
    (40) expression -> . IDENTIFIER
    (41) expression -> . IDENTIFIER LBRAKET expression RBRAKET

    LPAREN          shift and go to state 49
    NUMBER          shift and go to state 50
    CHAR_LITERAL    shift and go to state 51
    CHAR            shift and go to state 52
    IDENTIFIER      shift and go to state 53

    expression                     shift and go to state 97

state 78

    (17) declaration -> type_specifier IDENTIFIER EQUAL expression . SEMICOLON
    (32) expression -> expression . PLUS expression
    (33) expression -> expression . MINUS expression
    (34) expression -> expression . TIMES expression
    (35) expression -> expression . DIVIDE expression

    SEMICOLON       shift and go to state 98
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 75


state 79

    (15) identifier_list -> IDENTIFIER .
    (16) identifier_list -> IDENTIFIER . COMMA identifier_list

    SEMICOLON       reduce using rule 15 (identifier_list -> IDENTIFIER .)
    EQUAL           reduce using rule 15 (identifier_list -> IDENTIFIER .)
    LBRAKET         reduce using rule 15 (identifier_list -> IDENTIFIER .)
    COMMA           shift and go to state 55


state 80

    (16) identifier_list -> IDENTIFIER COMMA identifier_list .

    SEMICOLON       reduce using rule 16 (identifier_list -> IDENTIFIER COMMA identifier_list .)
    EQUAL           reduce using rule 16 (identifier_list -> IDENTIFIER COMMA identifier_list .)
    LBRAKET         reduce using rule 16 (identifier_list -> IDENTIFIER COMMA identifier_list .)


state 81

    (19) declaration -> type_specifier identifier_list EQUAL expression . SEMICOLON
    (32) expression -> expression . PLUS expression
    (33) expression -> expression . MINUS expression
    (34) expression -> expression . TIMES expression
    (35) expression -> expression . DIVIDE expression

    SEMICOLON       shift and go to state 99
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 75


state 82

    (20) declaration -> type_specifier identifier_list LBRAKET NUMBER . RBRAKET SEMICOLON

    RBRAKET         shift and go to state 100


state 83

    (28) assignment -> IDENTIFIER EQUAL expression SEMICOLON .

    IDENTIFIER      reduce using rule 28 (assignment -> IDENTIFIER EQUAL expression SEMICOLON .)
    FOR             reduce using rule 28 (assignment -> IDENTIFIER EQUAL expression SEMICOLON .)
    IF              reduce using rule 28 (assignment -> IDENTIFIER EQUAL expression SEMICOLON .)
    PRINTF          reduce using rule 28 (assignment -> IDENTIFIER EQUAL expression SEMICOLON .)
    SCANF           reduce using rule 28 (assignment -> IDENTIFIER EQUAL expression SEMICOLON .)
    RETURN          reduce using rule 28 (assignment -> IDENTIFIER EQUAL expression SEMICOLON .)
    INT             reduce using rule 28 (assignment -> IDENTIFIER EQUAL expression SEMICOLON .)
    FLOAT           reduce using rule 28 (assignment -> IDENTIFIER EQUAL expression SEMICOLON .)
    CHAR            reduce using rule 28 (assignment -> IDENTIFIER EQUAL expression SEMICOLON .)
    RBRACE          reduce using rule 28 (assignment -> IDENTIFIER EQUAL expression SEMICOLON .)
    LPAREN          reduce using rule 28 (assignment -> IDENTIFIER EQUAL expression SEMICOLON .)
    NUMBER          reduce using rule 28 (assignment -> IDENTIFIER EQUAL expression SEMICOLON .)
    CHAR_LITERAL    reduce using rule 28 (assignment -> IDENTIFIER EQUAL expression SEMICOLON .)


state 84

    (29) assignment -> IDENTIFIER compound_assignment expression SEMICOLON .

    IDENTIFIER      reduce using rule 29 (assignment -> IDENTIFIER compound_assignment expression SEMICOLON .)
    FOR             reduce using rule 29 (assignment -> IDENTIFIER compound_assignment expression SEMICOLON .)
    IF              reduce using rule 29 (assignment -> IDENTIFIER compound_assignment expression SEMICOLON .)
    PRINTF          reduce using rule 29 (assignment -> IDENTIFIER compound_assignment expression SEMICOLON .)
    SCANF           reduce using rule 29 (assignment -> IDENTIFIER compound_assignment expression SEMICOLON .)
    RETURN          reduce using rule 29 (assignment -> IDENTIFIER compound_assignment expression SEMICOLON .)
    INT             reduce using rule 29 (assignment -> IDENTIFIER compound_assignment expression SEMICOLON .)
    FLOAT           reduce using rule 29 (assignment -> IDENTIFIER compound_assignment expression SEMICOLON .)
    CHAR            reduce using rule 29 (assignment -> IDENTIFIER compound_assignment expression SEMICOLON .)
    RBRACE          reduce using rule 29 (assignment -> IDENTIFIER compound_assignment expression SEMICOLON .)
    LPAREN          reduce using rule 29 (assignment -> IDENTIFIER compound_assignment expression SEMICOLON .)
    NUMBER          reduce using rule 29 (assignment -> IDENTIFIER compound_assignment expression SEMICOLON .)
    CHAR_LITERAL    reduce using rule 29 (assignment -> IDENTIFIER compound_assignment expression SEMICOLON .)


state 85

    (30) assignment -> IDENTIFIER LBRAKET expression RBRAKET . compound_assignment expression SEMICOLON
    (31) assignment -> IDENTIFIER LBRAKET expression RBRAKET . EQUAL expression SEMICOLON
    (24) compound_assignment -> . PLUS EQUAL
    (25) compound_assignment -> . MINUS EQUAL
    (26) compound_assignment -> . TIMES EQUAL
    (27) compound_assignment -> . DIVIDE EQUAL

    EQUAL           shift and go to state 102
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    TIMES           shift and go to state 41
    DIVIDE          shift and go to state 42

    compound_assignment            shift and go to state 101

state 86

    (46) for_loop -> FOR LPAREN assignment condition . SEMICOLON unitarymodifiers RPAREN LBRACE statement_list RBRACE

    SEMICOLON       shift and go to state 103


state 87

    (48) if_statement -> IF LPAREN condition RPAREN . LBRACE statement_list RBRACE
    (49) if_statement -> IF LPAREN condition RPAREN . LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE

    LBRACE          shift and go to state 104


state 88

    (47) condition -> expression COMPARER . expression
    (32) expression -> . expression PLUS expression
    (33) expression -> . expression MINUS expression
    (34) expression -> . expression TIMES expression
    (35) expression -> . expression DIVIDE expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . NUMBER
    (38) expression -> . CHAR_LITERAL
    (39) expression -> . CHAR
    (40) expression -> . IDENTIFIER
    (41) expression -> . IDENTIFIER LBRAKET expression RBRAKET

    LPAREN          shift and go to state 49
    NUMBER          shift and go to state 50
    CHAR_LITERAL    shift and go to state 51
    CHAR            shift and go to state 52
    IDENTIFIER      shift and go to state 53

    expression                     shift and go to state 105

state 89

    (50) function_call -> PRINTF LPAREN STRING COMMA . IDENTIFIER RPAREN SEMICOLON
    (52) function_call -> PRINTF LPAREN STRING COMMA . expression_list RPAREN SEMICOLON
    (42) expression_list -> . expression
    (43) expression_list -> . expression COMMA expression_list
    (32) expression -> . expression PLUS expression
    (33) expression -> . expression MINUS expression
    (34) expression -> . expression TIMES expression
    (35) expression -> . expression DIVIDE expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . NUMBER
    (38) expression -> . CHAR_LITERAL
    (39) expression -> . CHAR
    (40) expression -> . IDENTIFIER
    (41) expression -> . IDENTIFIER LBRAKET expression RBRAKET

    IDENTIFIER      shift and go to state 106
    LPAREN          shift and go to state 49
    NUMBER          shift and go to state 50
    CHAR_LITERAL    shift and go to state 51
    CHAR            shift and go to state 52

    expression_list                shift and go to state 107
    expression                     shift and go to state 108

state 90

    (51) function_call -> PRINTF LPAREN STRING RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 109


state 91

    (53) function_call -> SCANF LPAREN STRING COMMA . AMPERSAND IDENTIFIER RPAREN SEMICOLON

    AMPERSAND       shift and go to state 110


state 92

    (32) expression -> expression PLUS expression .
    (32) expression -> expression . PLUS expression
    (33) expression -> expression . MINUS expression
    (34) expression -> expression . TIMES expression
    (35) expression -> expression . DIVIDE expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
    SEMICOLON       reduce using rule 32 (expression -> expression PLUS expression .)
    RBRAKET         reduce using rule 32 (expression -> expression PLUS expression .)
    COMPARER        reduce using rule 32 (expression -> expression PLUS expression .)
    RPAREN          reduce using rule 32 (expression -> expression PLUS expression .)
    COMMA           reduce using rule 32 (expression -> expression PLUS expression .)
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 75

  ! PLUS            [ reduce using rule 32 (expression -> expression PLUS expression .) ]
  ! MINUS           [ reduce using rule 32 (expression -> expression PLUS expression .) ]
  ! TIMES           [ reduce using rule 32 (expression -> expression PLUS expression .) ]
  ! DIVIDE          [ reduce using rule 32 (expression -> expression PLUS expression .) ]


state 93

    (33) expression -> expression MINUS expression .
    (32) expression -> expression . PLUS expression
    (33) expression -> expression . MINUS expression
    (34) expression -> expression . TIMES expression
    (35) expression -> expression . DIVIDE expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
    SEMICOLON       reduce using rule 33 (expression -> expression MINUS expression .)
    RBRAKET         reduce using rule 33 (expression -> expression MINUS expression .)
    COMPARER        reduce using rule 33 (expression -> expression MINUS expression .)
    RPAREN          reduce using rule 33 (expression -> expression MINUS expression .)
    COMMA           reduce using rule 33 (expression -> expression MINUS expression .)
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 75

  ! PLUS            [ reduce using rule 33 (expression -> expression MINUS expression .) ]
  ! MINUS           [ reduce using rule 33 (expression -> expression MINUS expression .) ]
  ! TIMES           [ reduce using rule 33 (expression -> expression MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 33 (expression -> expression MINUS expression .) ]


state 94

    (34) expression -> expression TIMES expression .
    (32) expression -> expression . PLUS expression
    (33) expression -> expression . MINUS expression
    (34) expression -> expression . TIMES expression
    (35) expression -> expression . DIVIDE expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
    SEMICOLON       reduce using rule 34 (expression -> expression TIMES expression .)
    RBRAKET         reduce using rule 34 (expression -> expression TIMES expression .)
    COMPARER        reduce using rule 34 (expression -> expression TIMES expression .)
    RPAREN          reduce using rule 34 (expression -> expression TIMES expression .)
    COMMA           reduce using rule 34 (expression -> expression TIMES expression .)
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 75

  ! PLUS            [ reduce using rule 34 (expression -> expression TIMES expression .) ]
  ! MINUS           [ reduce using rule 34 (expression -> expression TIMES expression .) ]
  ! TIMES           [ reduce using rule 34 (expression -> expression TIMES expression .) ]
  ! DIVIDE          [ reduce using rule 34 (expression -> expression TIMES expression .) ]


state 95

    (35) expression -> expression DIVIDE expression .
    (32) expression -> expression . PLUS expression
    (33) expression -> expression . MINUS expression
    (34) expression -> expression . TIMES expression
    (35) expression -> expression . DIVIDE expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
    SEMICOLON       reduce using rule 35 (expression -> expression DIVIDE expression .)
    RBRAKET         reduce using rule 35 (expression -> expression DIVIDE expression .)
    COMPARER        reduce using rule 35 (expression -> expression DIVIDE expression .)
    RPAREN          reduce using rule 35 (expression -> expression DIVIDE expression .)
    COMMA           reduce using rule 35 (expression -> expression DIVIDE expression .)
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 75

  ! PLUS            [ reduce using rule 35 (expression -> expression DIVIDE expression .) ]
  ! MINUS           [ reduce using rule 35 (expression -> expression DIVIDE expression .) ]
  ! TIMES           [ reduce using rule 35 (expression -> expression DIVIDE expression .) ]
  ! DIVIDE          [ reduce using rule 35 (expression -> expression DIVIDE expression .) ]


state 96

    (36) expression -> LPAREN expression RPAREN .

    SEMICOLON       reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    RBRAKET         reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    COMPARER        reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 36 (expression -> LPAREN expression RPAREN .)


state 97

    (41) expression -> IDENTIFIER LBRAKET expression . RBRAKET
    (32) expression -> expression . PLUS expression
    (33) expression -> expression . MINUS expression
    (34) expression -> expression . TIMES expression
    (35) expression -> expression . DIVIDE expression

    RBRAKET         shift and go to state 111
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 75


state 98

    (17) declaration -> type_specifier IDENTIFIER EQUAL expression SEMICOLON .

    IDENTIFIER      reduce using rule 17 (declaration -> type_specifier IDENTIFIER EQUAL expression SEMICOLON .)
    FOR             reduce using rule 17 (declaration -> type_specifier IDENTIFIER EQUAL expression SEMICOLON .)
    IF              reduce using rule 17 (declaration -> type_specifier IDENTIFIER EQUAL expression SEMICOLON .)
    PRINTF          reduce using rule 17 (declaration -> type_specifier IDENTIFIER EQUAL expression SEMICOLON .)
    SCANF           reduce using rule 17 (declaration -> type_specifier IDENTIFIER EQUAL expression SEMICOLON .)
    RETURN          reduce using rule 17 (declaration -> type_specifier IDENTIFIER EQUAL expression SEMICOLON .)
    INT             reduce using rule 17 (declaration -> type_specifier IDENTIFIER EQUAL expression SEMICOLON .)
    FLOAT           reduce using rule 17 (declaration -> type_specifier IDENTIFIER EQUAL expression SEMICOLON .)
    CHAR            reduce using rule 17 (declaration -> type_specifier IDENTIFIER EQUAL expression SEMICOLON .)
    RBRACE          reduce using rule 17 (declaration -> type_specifier IDENTIFIER EQUAL expression SEMICOLON .)


state 99

    (19) declaration -> type_specifier identifier_list EQUAL expression SEMICOLON .

    IDENTIFIER      reduce using rule 19 (declaration -> type_specifier identifier_list EQUAL expression SEMICOLON .)
    FOR             reduce using rule 19 (declaration -> type_specifier identifier_list EQUAL expression SEMICOLON .)
    IF              reduce using rule 19 (declaration -> type_specifier identifier_list EQUAL expression SEMICOLON .)
    PRINTF          reduce using rule 19 (declaration -> type_specifier identifier_list EQUAL expression SEMICOLON .)
    SCANF           reduce using rule 19 (declaration -> type_specifier identifier_list EQUAL expression SEMICOLON .)
    RETURN          reduce using rule 19 (declaration -> type_specifier identifier_list EQUAL expression SEMICOLON .)
    INT             reduce using rule 19 (declaration -> type_specifier identifier_list EQUAL expression SEMICOLON .)
    FLOAT           reduce using rule 19 (declaration -> type_specifier identifier_list EQUAL expression SEMICOLON .)
    CHAR            reduce using rule 19 (declaration -> type_specifier identifier_list EQUAL expression SEMICOLON .)
    RBRACE          reduce using rule 19 (declaration -> type_specifier identifier_list EQUAL expression SEMICOLON .)


state 100

    (20) declaration -> type_specifier identifier_list LBRAKET NUMBER RBRAKET . SEMICOLON

    SEMICOLON       shift and go to state 112


state 101

    (30) assignment -> IDENTIFIER LBRAKET expression RBRAKET compound_assignment . expression SEMICOLON
    (32) expression -> . expression PLUS expression
    (33) expression -> . expression MINUS expression
    (34) expression -> . expression TIMES expression
    (35) expression -> . expression DIVIDE expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . NUMBER
    (38) expression -> . CHAR_LITERAL
    (39) expression -> . CHAR
    (40) expression -> . IDENTIFIER
    (41) expression -> . IDENTIFIER LBRAKET expression RBRAKET

    LPAREN          shift and go to state 49
    NUMBER          shift and go to state 50
    CHAR_LITERAL    shift and go to state 51
    CHAR            shift and go to state 52
    IDENTIFIER      shift and go to state 53

    expression                     shift and go to state 113

state 102

    (31) assignment -> IDENTIFIER LBRAKET expression RBRAKET EQUAL . expression SEMICOLON
    (32) expression -> . expression PLUS expression
    (33) expression -> . expression MINUS expression
    (34) expression -> . expression TIMES expression
    (35) expression -> . expression DIVIDE expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . NUMBER
    (38) expression -> . CHAR_LITERAL
    (39) expression -> . CHAR
    (40) expression -> . IDENTIFIER
    (41) expression -> . IDENTIFIER LBRAKET expression RBRAKET

    LPAREN          shift and go to state 49
    NUMBER          shift and go to state 50
    CHAR_LITERAL    shift and go to state 51
    CHAR            shift and go to state 52
    IDENTIFIER      shift and go to state 53

    expression                     shift and go to state 114

state 103

    (46) for_loop -> FOR LPAREN assignment condition SEMICOLON . unitarymodifiers RPAREN LBRACE statement_list RBRACE
    (44) unitarymodifiers -> . IDENTIFIER PLUS PLUS
    (45) unitarymodifiers -> . IDENTIFIER MINUS MINUS

    IDENTIFIER      shift and go to state 116

    unitarymodifiers               shift and go to state 115

state 104

    (48) if_statement -> IF LPAREN condition RPAREN LBRACE . statement_list RBRACE
    (49) if_statement -> IF LPAREN condition RPAREN LBRACE . statement_list RBRACE ELSE LBRACE statement_list RBRACE
    (7) statement_list -> . statement statement_list
    (8) statement_list -> . statement
    (9) statement -> . declaration
    (10) statement -> . assignment
    (11) statement -> . for_loop
    (12) statement -> . if_statement
    (13) statement -> . function_call
    (14) statement -> . return_statement
    (17) declaration -> . type_specifier IDENTIFIER EQUAL expression SEMICOLON
    (18) declaration -> . type_specifier identifier_list SEMICOLON
    (19) declaration -> . type_specifier identifier_list EQUAL expression SEMICOLON
    (20) declaration -> . type_specifier identifier_list LBRAKET NUMBER RBRAKET SEMICOLON
    (28) assignment -> . IDENTIFIER EQUAL expression SEMICOLON
    (29) assignment -> . IDENTIFIER compound_assignment expression SEMICOLON
    (30) assignment -> . IDENTIFIER LBRAKET expression RBRAKET compound_assignment expression SEMICOLON
    (31) assignment -> . IDENTIFIER LBRAKET expression RBRAKET EQUAL expression SEMICOLON
    (46) for_loop -> . FOR LPAREN assignment condition SEMICOLON unitarymodifiers RPAREN LBRACE statement_list RBRACE
    (48) if_statement -> . IF LPAREN condition RPAREN LBRACE statement_list RBRACE
    (49) if_statement -> . IF LPAREN condition RPAREN LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE
    (50) function_call -> . PRINTF LPAREN STRING COMMA IDENTIFIER RPAREN SEMICOLON
    (51) function_call -> . PRINTF LPAREN STRING RPAREN SEMICOLON
    (52) function_call -> . PRINTF LPAREN STRING COMMA expression_list RPAREN SEMICOLON
    (53) function_call -> . SCANF LPAREN STRING COMMA AMPERSAND IDENTIFIER RPAREN SEMICOLON
    (54) return_statement -> . RETURN SEMICOLON
    (55) return_statement -> . RETURN expression SEMICOLON
    (21) type_specifier -> . INT
    (22) type_specifier -> . FLOAT
    (23) type_specifier -> . CHAR

    IDENTIFIER      shift and go to state 24
    FOR             shift and go to state 25
    IF              shift and go to state 26
    PRINTF          shift and go to state 27
    SCANF           shift and go to state 28
    RETURN          shift and go to state 29
    INT             shift and go to state 14
    FLOAT           shift and go to state 30
    CHAR            shift and go to state 31

    statement_list                 shift and go to state 117
    statement                      shift and go to state 16
    declaration                    shift and go to state 17
    assignment                     shift and go to state 18
    for_loop                       shift and go to state 19
    if_statement                   shift and go to state 20
    function_call                  shift and go to state 21
    return_statement               shift and go to state 22
    type_specifier                 shift and go to state 23

state 105

    (47) condition -> expression COMPARER expression .
    (32) expression -> expression . PLUS expression
    (33) expression -> expression . MINUS expression
    (34) expression -> expression . TIMES expression
    (35) expression -> expression . DIVIDE expression

    RPAREN          reduce using rule 47 (condition -> expression COMPARER expression .)
    SEMICOLON       reduce using rule 47 (condition -> expression COMPARER expression .)
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 75


state 106

    (50) function_call -> PRINTF LPAREN STRING COMMA IDENTIFIER . RPAREN SEMICOLON
    (40) expression -> IDENTIFIER .
    (41) expression -> IDENTIFIER . LBRAKET expression RBRAKET

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 118
    COMMA           reduce using rule 40 (expression -> IDENTIFIER .)
    PLUS            reduce using rule 40 (expression -> IDENTIFIER .)
    MINUS           reduce using rule 40 (expression -> IDENTIFIER .)
    TIMES           reduce using rule 40 (expression -> IDENTIFIER .)
    DIVIDE          reduce using rule 40 (expression -> IDENTIFIER .)
    LBRAKET         shift and go to state 77

  ! RPAREN          [ reduce using rule 40 (expression -> IDENTIFIER .) ]


state 107

    (52) function_call -> PRINTF LPAREN STRING COMMA expression_list . RPAREN SEMICOLON

    RPAREN          shift and go to state 119


state 108

    (42) expression_list -> expression .
    (43) expression_list -> expression . COMMA expression_list
    (32) expression -> expression . PLUS expression
    (33) expression -> expression . MINUS expression
    (34) expression -> expression . TIMES expression
    (35) expression -> expression . DIVIDE expression

    RPAREN          reduce using rule 42 (expression_list -> expression .)
    COMMA           shift and go to state 120
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 75


state 109

    (51) function_call -> PRINTF LPAREN STRING RPAREN SEMICOLON .

    IDENTIFIER      reduce using rule 51 (function_call -> PRINTF LPAREN STRING RPAREN SEMICOLON .)
    FOR             reduce using rule 51 (function_call -> PRINTF LPAREN STRING RPAREN SEMICOLON .)
    IF              reduce using rule 51 (function_call -> PRINTF LPAREN STRING RPAREN SEMICOLON .)
    PRINTF          reduce using rule 51 (function_call -> PRINTF LPAREN STRING RPAREN SEMICOLON .)
    SCANF           reduce using rule 51 (function_call -> PRINTF LPAREN STRING RPAREN SEMICOLON .)
    RETURN          reduce using rule 51 (function_call -> PRINTF LPAREN STRING RPAREN SEMICOLON .)
    INT             reduce using rule 51 (function_call -> PRINTF LPAREN STRING RPAREN SEMICOLON .)
    FLOAT           reduce using rule 51 (function_call -> PRINTF LPAREN STRING RPAREN SEMICOLON .)
    CHAR            reduce using rule 51 (function_call -> PRINTF LPAREN STRING RPAREN SEMICOLON .)
    RBRACE          reduce using rule 51 (function_call -> PRINTF LPAREN STRING RPAREN SEMICOLON .)


state 110

    (53) function_call -> SCANF LPAREN STRING COMMA AMPERSAND . IDENTIFIER RPAREN SEMICOLON

    IDENTIFIER      shift and go to state 121


state 111

    (41) expression -> IDENTIFIER LBRAKET expression RBRAKET .

    SEMICOLON       reduce using rule 41 (expression -> IDENTIFIER LBRAKET expression RBRAKET .)
    PLUS            reduce using rule 41 (expression -> IDENTIFIER LBRAKET expression RBRAKET .)
    MINUS           reduce using rule 41 (expression -> IDENTIFIER LBRAKET expression RBRAKET .)
    TIMES           reduce using rule 41 (expression -> IDENTIFIER LBRAKET expression RBRAKET .)
    DIVIDE          reduce using rule 41 (expression -> IDENTIFIER LBRAKET expression RBRAKET .)
    RBRAKET         reduce using rule 41 (expression -> IDENTIFIER LBRAKET expression RBRAKET .)
    COMPARER        reduce using rule 41 (expression -> IDENTIFIER LBRAKET expression RBRAKET .)
    RPAREN          reduce using rule 41 (expression -> IDENTIFIER LBRAKET expression RBRAKET .)
    COMMA           reduce using rule 41 (expression -> IDENTIFIER LBRAKET expression RBRAKET .)


state 112

    (20) declaration -> type_specifier identifier_list LBRAKET NUMBER RBRAKET SEMICOLON .

    IDENTIFIER      reduce using rule 20 (declaration -> type_specifier identifier_list LBRAKET NUMBER RBRAKET SEMICOLON .)
    FOR             reduce using rule 20 (declaration -> type_specifier identifier_list LBRAKET NUMBER RBRAKET SEMICOLON .)
    IF              reduce using rule 20 (declaration -> type_specifier identifier_list LBRAKET NUMBER RBRAKET SEMICOLON .)
    PRINTF          reduce using rule 20 (declaration -> type_specifier identifier_list LBRAKET NUMBER RBRAKET SEMICOLON .)
    SCANF           reduce using rule 20 (declaration -> type_specifier identifier_list LBRAKET NUMBER RBRAKET SEMICOLON .)
    RETURN          reduce using rule 20 (declaration -> type_specifier identifier_list LBRAKET NUMBER RBRAKET SEMICOLON .)
    INT             reduce using rule 20 (declaration -> type_specifier identifier_list LBRAKET NUMBER RBRAKET SEMICOLON .)
    FLOAT           reduce using rule 20 (declaration -> type_specifier identifier_list LBRAKET NUMBER RBRAKET SEMICOLON .)
    CHAR            reduce using rule 20 (declaration -> type_specifier identifier_list LBRAKET NUMBER RBRAKET SEMICOLON .)
    RBRACE          reduce using rule 20 (declaration -> type_specifier identifier_list LBRAKET NUMBER RBRAKET SEMICOLON .)


state 113

    (30) assignment -> IDENTIFIER LBRAKET expression RBRAKET compound_assignment expression . SEMICOLON
    (32) expression -> expression . PLUS expression
    (33) expression -> expression . MINUS expression
    (34) expression -> expression . TIMES expression
    (35) expression -> expression . DIVIDE expression

    SEMICOLON       shift and go to state 122
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 75


state 114

    (31) assignment -> IDENTIFIER LBRAKET expression RBRAKET EQUAL expression . SEMICOLON
    (32) expression -> expression . PLUS expression
    (33) expression -> expression . MINUS expression
    (34) expression -> expression . TIMES expression
    (35) expression -> expression . DIVIDE expression

    SEMICOLON       shift and go to state 123
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 75


state 115

    (46) for_loop -> FOR LPAREN assignment condition SEMICOLON unitarymodifiers . RPAREN LBRACE statement_list RBRACE

    RPAREN          shift and go to state 124


state 116

    (44) unitarymodifiers -> IDENTIFIER . PLUS PLUS
    (45) unitarymodifiers -> IDENTIFIER . MINUS MINUS

    PLUS            shift and go to state 125
    MINUS           shift and go to state 126


state 117

    (48) if_statement -> IF LPAREN condition RPAREN LBRACE statement_list . RBRACE
    (49) if_statement -> IF LPAREN condition RPAREN LBRACE statement_list . RBRACE ELSE LBRACE statement_list RBRACE

    RBRACE          shift and go to state 127


state 118

    (50) function_call -> PRINTF LPAREN STRING COMMA IDENTIFIER RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 128


state 119

    (52) function_call -> PRINTF LPAREN STRING COMMA expression_list RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 129


state 120

    (43) expression_list -> expression COMMA . expression_list
    (42) expression_list -> . expression
    (43) expression_list -> . expression COMMA expression_list
    (32) expression -> . expression PLUS expression
    (33) expression -> . expression MINUS expression
    (34) expression -> . expression TIMES expression
    (35) expression -> . expression DIVIDE expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . NUMBER
    (38) expression -> . CHAR_LITERAL
    (39) expression -> . CHAR
    (40) expression -> . IDENTIFIER
    (41) expression -> . IDENTIFIER LBRAKET expression RBRAKET

    LPAREN          shift and go to state 49
    NUMBER          shift and go to state 50
    CHAR_LITERAL    shift and go to state 51
    CHAR            shift and go to state 52
    IDENTIFIER      shift and go to state 53

    expression                     shift and go to state 108
    expression_list                shift and go to state 130

state 121

    (53) function_call -> SCANF LPAREN STRING COMMA AMPERSAND IDENTIFIER . RPAREN SEMICOLON

    RPAREN          shift and go to state 131


state 122

    (30) assignment -> IDENTIFIER LBRAKET expression RBRAKET compound_assignment expression SEMICOLON .

    IDENTIFIER      reduce using rule 30 (assignment -> IDENTIFIER LBRAKET expression RBRAKET compound_assignment expression SEMICOLON .)
    FOR             reduce using rule 30 (assignment -> IDENTIFIER LBRAKET expression RBRAKET compound_assignment expression SEMICOLON .)
    IF              reduce using rule 30 (assignment -> IDENTIFIER LBRAKET expression RBRAKET compound_assignment expression SEMICOLON .)
    PRINTF          reduce using rule 30 (assignment -> IDENTIFIER LBRAKET expression RBRAKET compound_assignment expression SEMICOLON .)
    SCANF           reduce using rule 30 (assignment -> IDENTIFIER LBRAKET expression RBRAKET compound_assignment expression SEMICOLON .)
    RETURN          reduce using rule 30 (assignment -> IDENTIFIER LBRAKET expression RBRAKET compound_assignment expression SEMICOLON .)
    INT             reduce using rule 30 (assignment -> IDENTIFIER LBRAKET expression RBRAKET compound_assignment expression SEMICOLON .)
    FLOAT           reduce using rule 30 (assignment -> IDENTIFIER LBRAKET expression RBRAKET compound_assignment expression SEMICOLON .)
    CHAR            reduce using rule 30 (assignment -> IDENTIFIER LBRAKET expression RBRAKET compound_assignment expression SEMICOLON .)
    RBRACE          reduce using rule 30 (assignment -> IDENTIFIER LBRAKET expression RBRAKET compound_assignment expression SEMICOLON .)
    LPAREN          reduce using rule 30 (assignment -> IDENTIFIER LBRAKET expression RBRAKET compound_assignment expression SEMICOLON .)
    NUMBER          reduce using rule 30 (assignment -> IDENTIFIER LBRAKET expression RBRAKET compound_assignment expression SEMICOLON .)
    CHAR_LITERAL    reduce using rule 30 (assignment -> IDENTIFIER LBRAKET expression RBRAKET compound_assignment expression SEMICOLON .)


state 123

    (31) assignment -> IDENTIFIER LBRAKET expression RBRAKET EQUAL expression SEMICOLON .

    IDENTIFIER      reduce using rule 31 (assignment -> IDENTIFIER LBRAKET expression RBRAKET EQUAL expression SEMICOLON .)
    FOR             reduce using rule 31 (assignment -> IDENTIFIER LBRAKET expression RBRAKET EQUAL expression SEMICOLON .)
    IF              reduce using rule 31 (assignment -> IDENTIFIER LBRAKET expression RBRAKET EQUAL expression SEMICOLON .)
    PRINTF          reduce using rule 31 (assignment -> IDENTIFIER LBRAKET expression RBRAKET EQUAL expression SEMICOLON .)
    SCANF           reduce using rule 31 (assignment -> IDENTIFIER LBRAKET expression RBRAKET EQUAL expression SEMICOLON .)
    RETURN          reduce using rule 31 (assignment -> IDENTIFIER LBRAKET expression RBRAKET EQUAL expression SEMICOLON .)
    INT             reduce using rule 31 (assignment -> IDENTIFIER LBRAKET expression RBRAKET EQUAL expression SEMICOLON .)
    FLOAT           reduce using rule 31 (assignment -> IDENTIFIER LBRAKET expression RBRAKET EQUAL expression SEMICOLON .)
    CHAR            reduce using rule 31 (assignment -> IDENTIFIER LBRAKET expression RBRAKET EQUAL expression SEMICOLON .)
    RBRACE          reduce using rule 31 (assignment -> IDENTIFIER LBRAKET expression RBRAKET EQUAL expression SEMICOLON .)
    LPAREN          reduce using rule 31 (assignment -> IDENTIFIER LBRAKET expression RBRAKET EQUAL expression SEMICOLON .)
    NUMBER          reduce using rule 31 (assignment -> IDENTIFIER LBRAKET expression RBRAKET EQUAL expression SEMICOLON .)
    CHAR_LITERAL    reduce using rule 31 (assignment -> IDENTIFIER LBRAKET expression RBRAKET EQUAL expression SEMICOLON .)


state 124

    (46) for_loop -> FOR LPAREN assignment condition SEMICOLON unitarymodifiers RPAREN . LBRACE statement_list RBRACE

    LBRACE          shift and go to state 132


state 125

    (44) unitarymodifiers -> IDENTIFIER PLUS . PLUS

    PLUS            shift and go to state 133


state 126

    (45) unitarymodifiers -> IDENTIFIER MINUS . MINUS

    MINUS           shift and go to state 134


state 127

    (48) if_statement -> IF LPAREN condition RPAREN LBRACE statement_list RBRACE .
    (49) if_statement -> IF LPAREN condition RPAREN LBRACE statement_list RBRACE . ELSE LBRACE statement_list RBRACE

    IDENTIFIER      reduce using rule 48 (if_statement -> IF LPAREN condition RPAREN LBRACE statement_list RBRACE .)
    FOR             reduce using rule 48 (if_statement -> IF LPAREN condition RPAREN LBRACE statement_list RBRACE .)
    IF              reduce using rule 48 (if_statement -> IF LPAREN condition RPAREN LBRACE statement_list RBRACE .)
    PRINTF          reduce using rule 48 (if_statement -> IF LPAREN condition RPAREN LBRACE statement_list RBRACE .)
    SCANF           reduce using rule 48 (if_statement -> IF LPAREN condition RPAREN LBRACE statement_list RBRACE .)
    RETURN          reduce using rule 48 (if_statement -> IF LPAREN condition RPAREN LBRACE statement_list RBRACE .)
    INT             reduce using rule 48 (if_statement -> IF LPAREN condition RPAREN LBRACE statement_list RBRACE .)
    FLOAT           reduce using rule 48 (if_statement -> IF LPAREN condition RPAREN LBRACE statement_list RBRACE .)
    CHAR            reduce using rule 48 (if_statement -> IF LPAREN condition RPAREN LBRACE statement_list RBRACE .)
    RBRACE          reduce using rule 48 (if_statement -> IF LPAREN condition RPAREN LBRACE statement_list RBRACE .)
    ELSE            shift and go to state 135


state 128

    (50) function_call -> PRINTF LPAREN STRING COMMA IDENTIFIER RPAREN SEMICOLON .

    IDENTIFIER      reduce using rule 50 (function_call -> PRINTF LPAREN STRING COMMA IDENTIFIER RPAREN SEMICOLON .)
    FOR             reduce using rule 50 (function_call -> PRINTF LPAREN STRING COMMA IDENTIFIER RPAREN SEMICOLON .)
    IF              reduce using rule 50 (function_call -> PRINTF LPAREN STRING COMMA IDENTIFIER RPAREN SEMICOLON .)
    PRINTF          reduce using rule 50 (function_call -> PRINTF LPAREN STRING COMMA IDENTIFIER RPAREN SEMICOLON .)
    SCANF           reduce using rule 50 (function_call -> PRINTF LPAREN STRING COMMA IDENTIFIER RPAREN SEMICOLON .)
    RETURN          reduce using rule 50 (function_call -> PRINTF LPAREN STRING COMMA IDENTIFIER RPAREN SEMICOLON .)
    INT             reduce using rule 50 (function_call -> PRINTF LPAREN STRING COMMA IDENTIFIER RPAREN SEMICOLON .)
    FLOAT           reduce using rule 50 (function_call -> PRINTF LPAREN STRING COMMA IDENTIFIER RPAREN SEMICOLON .)
    CHAR            reduce using rule 50 (function_call -> PRINTF LPAREN STRING COMMA IDENTIFIER RPAREN SEMICOLON .)
    RBRACE          reduce using rule 50 (function_call -> PRINTF LPAREN STRING COMMA IDENTIFIER RPAREN SEMICOLON .)


state 129

    (52) function_call -> PRINTF LPAREN STRING COMMA expression_list RPAREN SEMICOLON .

    IDENTIFIER      reduce using rule 52 (function_call -> PRINTF LPAREN STRING COMMA expression_list RPAREN SEMICOLON .)
    FOR             reduce using rule 52 (function_call -> PRINTF LPAREN STRING COMMA expression_list RPAREN SEMICOLON .)
    IF              reduce using rule 52 (function_call -> PRINTF LPAREN STRING COMMA expression_list RPAREN SEMICOLON .)
    PRINTF          reduce using rule 52 (function_call -> PRINTF LPAREN STRING COMMA expression_list RPAREN SEMICOLON .)
    SCANF           reduce using rule 52 (function_call -> PRINTF LPAREN STRING COMMA expression_list RPAREN SEMICOLON .)
    RETURN          reduce using rule 52 (function_call -> PRINTF LPAREN STRING COMMA expression_list RPAREN SEMICOLON .)
    INT             reduce using rule 52 (function_call -> PRINTF LPAREN STRING COMMA expression_list RPAREN SEMICOLON .)
    FLOAT           reduce using rule 52 (function_call -> PRINTF LPAREN STRING COMMA expression_list RPAREN SEMICOLON .)
    CHAR            reduce using rule 52 (function_call -> PRINTF LPAREN STRING COMMA expression_list RPAREN SEMICOLON .)
    RBRACE          reduce using rule 52 (function_call -> PRINTF LPAREN STRING COMMA expression_list RPAREN SEMICOLON .)


state 130

    (43) expression_list -> expression COMMA expression_list .

    RPAREN          reduce using rule 43 (expression_list -> expression COMMA expression_list .)


state 131

    (53) function_call -> SCANF LPAREN STRING COMMA AMPERSAND IDENTIFIER RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 136


state 132

    (46) for_loop -> FOR LPAREN assignment condition SEMICOLON unitarymodifiers RPAREN LBRACE . statement_list RBRACE
    (7) statement_list -> . statement statement_list
    (8) statement_list -> . statement
    (9) statement -> . declaration
    (10) statement -> . assignment
    (11) statement -> . for_loop
    (12) statement -> . if_statement
    (13) statement -> . function_call
    (14) statement -> . return_statement
    (17) declaration -> . type_specifier IDENTIFIER EQUAL expression SEMICOLON
    (18) declaration -> . type_specifier identifier_list SEMICOLON
    (19) declaration -> . type_specifier identifier_list EQUAL expression SEMICOLON
    (20) declaration -> . type_specifier identifier_list LBRAKET NUMBER RBRAKET SEMICOLON
    (28) assignment -> . IDENTIFIER EQUAL expression SEMICOLON
    (29) assignment -> . IDENTIFIER compound_assignment expression SEMICOLON
    (30) assignment -> . IDENTIFIER LBRAKET expression RBRAKET compound_assignment expression SEMICOLON
    (31) assignment -> . IDENTIFIER LBRAKET expression RBRAKET EQUAL expression SEMICOLON
    (46) for_loop -> . FOR LPAREN assignment condition SEMICOLON unitarymodifiers RPAREN LBRACE statement_list RBRACE
    (48) if_statement -> . IF LPAREN condition RPAREN LBRACE statement_list RBRACE
    (49) if_statement -> . IF LPAREN condition RPAREN LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE
    (50) function_call -> . PRINTF LPAREN STRING COMMA IDENTIFIER RPAREN SEMICOLON
    (51) function_call -> . PRINTF LPAREN STRING RPAREN SEMICOLON
    (52) function_call -> . PRINTF LPAREN STRING COMMA expression_list RPAREN SEMICOLON
    (53) function_call -> . SCANF LPAREN STRING COMMA AMPERSAND IDENTIFIER RPAREN SEMICOLON
    (54) return_statement -> . RETURN SEMICOLON
    (55) return_statement -> . RETURN expression SEMICOLON
    (21) type_specifier -> . INT
    (22) type_specifier -> . FLOAT
    (23) type_specifier -> . CHAR

    IDENTIFIER      shift and go to state 24
    FOR             shift and go to state 25
    IF              shift and go to state 26
    PRINTF          shift and go to state 27
    SCANF           shift and go to state 28
    RETURN          shift and go to state 29
    INT             shift and go to state 14
    FLOAT           shift and go to state 30
    CHAR            shift and go to state 31

    assignment                     shift and go to state 18
    statement_list                 shift and go to state 137
    statement                      shift and go to state 16
    declaration                    shift and go to state 17
    for_loop                       shift and go to state 19
    if_statement                   shift and go to state 20
    function_call                  shift and go to state 21
    return_statement               shift and go to state 22
    type_specifier                 shift and go to state 23

state 133

    (44) unitarymodifiers -> IDENTIFIER PLUS PLUS .

    RPAREN          reduce using rule 44 (unitarymodifiers -> IDENTIFIER PLUS PLUS .)


state 134

    (45) unitarymodifiers -> IDENTIFIER MINUS MINUS .

    RPAREN          reduce using rule 45 (unitarymodifiers -> IDENTIFIER MINUS MINUS .)


state 135

    (49) if_statement -> IF LPAREN condition RPAREN LBRACE statement_list RBRACE ELSE . LBRACE statement_list RBRACE

    LBRACE          shift and go to state 138


state 136

    (53) function_call -> SCANF LPAREN STRING COMMA AMPERSAND IDENTIFIER RPAREN SEMICOLON .

    IDENTIFIER      reduce using rule 53 (function_call -> SCANF LPAREN STRING COMMA AMPERSAND IDENTIFIER RPAREN SEMICOLON .)
    FOR             reduce using rule 53 (function_call -> SCANF LPAREN STRING COMMA AMPERSAND IDENTIFIER RPAREN SEMICOLON .)
    IF              reduce using rule 53 (function_call -> SCANF LPAREN STRING COMMA AMPERSAND IDENTIFIER RPAREN SEMICOLON .)
    PRINTF          reduce using rule 53 (function_call -> SCANF LPAREN STRING COMMA AMPERSAND IDENTIFIER RPAREN SEMICOLON .)
    SCANF           reduce using rule 53 (function_call -> SCANF LPAREN STRING COMMA AMPERSAND IDENTIFIER RPAREN SEMICOLON .)
    RETURN          reduce using rule 53 (function_call -> SCANF LPAREN STRING COMMA AMPERSAND IDENTIFIER RPAREN SEMICOLON .)
    INT             reduce using rule 53 (function_call -> SCANF LPAREN STRING COMMA AMPERSAND IDENTIFIER RPAREN SEMICOLON .)
    FLOAT           reduce using rule 53 (function_call -> SCANF LPAREN STRING COMMA AMPERSAND IDENTIFIER RPAREN SEMICOLON .)
    CHAR            reduce using rule 53 (function_call -> SCANF LPAREN STRING COMMA AMPERSAND IDENTIFIER RPAREN SEMICOLON .)
    RBRACE          reduce using rule 53 (function_call -> SCANF LPAREN STRING COMMA AMPERSAND IDENTIFIER RPAREN SEMICOLON .)


state 137

    (46) for_loop -> FOR LPAREN assignment condition SEMICOLON unitarymodifiers RPAREN LBRACE statement_list . RBRACE

    RBRACE          shift and go to state 139


state 138

    (49) if_statement -> IF LPAREN condition RPAREN LBRACE statement_list RBRACE ELSE LBRACE . statement_list RBRACE
    (7) statement_list -> . statement statement_list
    (8) statement_list -> . statement
    (9) statement -> . declaration
    (10) statement -> . assignment
    (11) statement -> . for_loop
    (12) statement -> . if_statement
    (13) statement -> . function_call
    (14) statement -> . return_statement
    (17) declaration -> . type_specifier IDENTIFIER EQUAL expression SEMICOLON
    (18) declaration -> . type_specifier identifier_list SEMICOLON
    (19) declaration -> . type_specifier identifier_list EQUAL expression SEMICOLON
    (20) declaration -> . type_specifier identifier_list LBRAKET NUMBER RBRAKET SEMICOLON
    (28) assignment -> . IDENTIFIER EQUAL expression SEMICOLON
    (29) assignment -> . IDENTIFIER compound_assignment expression SEMICOLON
    (30) assignment -> . IDENTIFIER LBRAKET expression RBRAKET compound_assignment expression SEMICOLON
    (31) assignment -> . IDENTIFIER LBRAKET expression RBRAKET EQUAL expression SEMICOLON
    (46) for_loop -> . FOR LPAREN assignment condition SEMICOLON unitarymodifiers RPAREN LBRACE statement_list RBRACE
    (48) if_statement -> . IF LPAREN condition RPAREN LBRACE statement_list RBRACE
    (49) if_statement -> . IF LPAREN condition RPAREN LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE
    (50) function_call -> . PRINTF LPAREN STRING COMMA IDENTIFIER RPAREN SEMICOLON
    (51) function_call -> . PRINTF LPAREN STRING RPAREN SEMICOLON
    (52) function_call -> . PRINTF LPAREN STRING COMMA expression_list RPAREN SEMICOLON
    (53) function_call -> . SCANF LPAREN STRING COMMA AMPERSAND IDENTIFIER RPAREN SEMICOLON
    (54) return_statement -> . RETURN SEMICOLON
    (55) return_statement -> . RETURN expression SEMICOLON
    (21) type_specifier -> . INT
    (22) type_specifier -> . FLOAT
    (23) type_specifier -> . CHAR

    IDENTIFIER      shift and go to state 24
    FOR             shift and go to state 25
    IF              shift and go to state 26
    PRINTF          shift and go to state 27
    SCANF           shift and go to state 28
    RETURN          shift and go to state 29
    INT             shift and go to state 14
    FLOAT           shift and go to state 30
    CHAR            shift and go to state 31

    statement_list                 shift and go to state 140
    statement                      shift and go to state 16
    declaration                    shift and go to state 17
    assignment                     shift and go to state 18
    for_loop                       shift and go to state 19
    if_statement                   shift and go to state 20
    function_call                  shift and go to state 21
    return_statement               shift and go to state 22
    type_specifier                 shift and go to state 23

state 139

    (46) for_loop -> FOR LPAREN assignment condition SEMICOLON unitarymodifiers RPAREN LBRACE statement_list RBRACE .

    IDENTIFIER      reduce using rule 46 (for_loop -> FOR LPAREN assignment condition SEMICOLON unitarymodifiers RPAREN LBRACE statement_list RBRACE .)
    FOR             reduce using rule 46 (for_loop -> FOR LPAREN assignment condition SEMICOLON unitarymodifiers RPAREN LBRACE statement_list RBRACE .)
    IF              reduce using rule 46 (for_loop -> FOR LPAREN assignment condition SEMICOLON unitarymodifiers RPAREN LBRACE statement_list RBRACE .)
    PRINTF          reduce using rule 46 (for_loop -> FOR LPAREN assignment condition SEMICOLON unitarymodifiers RPAREN LBRACE statement_list RBRACE .)
    SCANF           reduce using rule 46 (for_loop -> FOR LPAREN assignment condition SEMICOLON unitarymodifiers RPAREN LBRACE statement_list RBRACE .)
    RETURN          reduce using rule 46 (for_loop -> FOR LPAREN assignment condition SEMICOLON unitarymodifiers RPAREN LBRACE statement_list RBRACE .)
    INT             reduce using rule 46 (for_loop -> FOR LPAREN assignment condition SEMICOLON unitarymodifiers RPAREN LBRACE statement_list RBRACE .)
    FLOAT           reduce using rule 46 (for_loop -> FOR LPAREN assignment condition SEMICOLON unitarymodifiers RPAREN LBRACE statement_list RBRACE .)
    CHAR            reduce using rule 46 (for_loop -> FOR LPAREN assignment condition SEMICOLON unitarymodifiers RPAREN LBRACE statement_list RBRACE .)
    RBRACE          reduce using rule 46 (for_loop -> FOR LPAREN assignment condition SEMICOLON unitarymodifiers RPAREN LBRACE statement_list RBRACE .)


state 140

    (49) if_statement -> IF LPAREN condition RPAREN LBRACE statement_list RBRACE ELSE LBRACE statement_list . RBRACE

    RBRACE          shift and go to state 141


state 141

    (49) if_statement -> IF LPAREN condition RPAREN LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE .

    IDENTIFIER      reduce using rule 49 (if_statement -> IF LPAREN condition RPAREN LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE .)
    FOR             reduce using rule 49 (if_statement -> IF LPAREN condition RPAREN LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE .)
    IF              reduce using rule 49 (if_statement -> IF LPAREN condition RPAREN LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE .)
    PRINTF          reduce using rule 49 (if_statement -> IF LPAREN condition RPAREN LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE .)
    SCANF           reduce using rule 49 (if_statement -> IF LPAREN condition RPAREN LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE .)
    RETURN          reduce using rule 49 (if_statement -> IF LPAREN condition RPAREN LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE .)
    INT             reduce using rule 49 (if_statement -> IF LPAREN condition RPAREN LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE .)
    FLOAT           reduce using rule 49 (if_statement -> IF LPAREN condition RPAREN LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE .)
    CHAR            reduce using rule 49 (if_statement -> IF LPAREN condition RPAREN LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE .)
    RBRACE          reduce using rule 49 (if_statement -> IF LPAREN condition RPAREN LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for EQUAL in state 34 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 92 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 92 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 92 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 92 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 93 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 93 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 93 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 93 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 94 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 94 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 94 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 94 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 95 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 95 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 95 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 95 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 106 resolved as shift
